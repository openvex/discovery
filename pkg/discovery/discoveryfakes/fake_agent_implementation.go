// Code generated by counterfeiter. DO NOT EDIT.
package discoveryfakes

import (
	"sync"

	"github.com/openvex/discovery/pkg/discovery"
	"github.com/openvex/discovery/pkg/discovery/options"
	"github.com/openvex/go-vex/pkg/vex"
	packageurl "github.com/package-url/packageurl-go"
)

type FakeAgentImplementation struct {
	FindDocumentsFromPurlStub        func(options.Options, discovery.VexProbe, *packageurl.PackageURL) ([]*vex.VEX, error)
	findDocumentsFromPurlMutex       sync.RWMutex
	findDocumentsFromPurlArgsForCall []struct {
		arg1 options.Options
		arg2 discovery.VexProbe
		arg3 *packageurl.PackageURL
	}
	findDocumentsFromPurlReturns struct {
		result1 []*vex.VEX
		result2 error
	}
	findDocumentsFromPurlReturnsOnCall map[int]struct {
		result1 []*vex.VEX
		result2 error
	}
	GetPackageProbeStub        func(options.Options, *packageurl.PackageURL) (discovery.VexProbe, error)
	getPackageProbeMutex       sync.RWMutex
	getPackageProbeArgsForCall []struct {
		arg1 options.Options
		arg2 *packageurl.PackageURL
	}
	getPackageProbeReturns struct {
		result1 discovery.VexProbe
		result2 error
	}
	getPackageProbeReturnsOnCall map[int]struct {
		result1 discovery.VexProbe
		result2 error
	}
	ParsePurlStub        func(string) (*packageurl.PackageURL, error)
	parsePurlMutex       sync.RWMutex
	parsePurlArgsForCall []struct {
		arg1 string
	}
	parsePurlReturns struct {
		result1 *packageurl.PackageURL
		result2 error
	}
	parsePurlReturnsOnCall map[int]struct {
		result1 *packageurl.PackageURL
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAgentImplementation) FindDocumentsFromPurl(arg1 options.Options, arg2 discovery.VexProbe, arg3 *packageurl.PackageURL) ([]*vex.VEX, error) {
	fake.findDocumentsFromPurlMutex.Lock()
	ret, specificReturn := fake.findDocumentsFromPurlReturnsOnCall[len(fake.findDocumentsFromPurlArgsForCall)]
	fake.findDocumentsFromPurlArgsForCall = append(fake.findDocumentsFromPurlArgsForCall, struct {
		arg1 options.Options
		arg2 discovery.VexProbe
		arg3 *packageurl.PackageURL
	}{arg1, arg2, arg3})
	stub := fake.FindDocumentsFromPurlStub
	fakeReturns := fake.findDocumentsFromPurlReturns
	fake.recordInvocation("FindDocumentsFromPurl", []interface{}{arg1, arg2, arg3})
	fake.findDocumentsFromPurlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAgentImplementation) FindDocumentsFromPurlCallCount() int {
	fake.findDocumentsFromPurlMutex.RLock()
	defer fake.findDocumentsFromPurlMutex.RUnlock()
	return len(fake.findDocumentsFromPurlArgsForCall)
}

func (fake *FakeAgentImplementation) FindDocumentsFromPurlCalls(stub func(options.Options, discovery.VexProbe, *packageurl.PackageURL) ([]*vex.VEX, error)) {
	fake.findDocumentsFromPurlMutex.Lock()
	defer fake.findDocumentsFromPurlMutex.Unlock()
	fake.FindDocumentsFromPurlStub = stub
}

func (fake *FakeAgentImplementation) FindDocumentsFromPurlArgsForCall(i int) (options.Options, discovery.VexProbe, *packageurl.PackageURL) {
	fake.findDocumentsFromPurlMutex.RLock()
	defer fake.findDocumentsFromPurlMutex.RUnlock()
	argsForCall := fake.findDocumentsFromPurlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAgentImplementation) FindDocumentsFromPurlReturns(result1 []*vex.VEX, result2 error) {
	fake.findDocumentsFromPurlMutex.Lock()
	defer fake.findDocumentsFromPurlMutex.Unlock()
	fake.FindDocumentsFromPurlStub = nil
	fake.findDocumentsFromPurlReturns = struct {
		result1 []*vex.VEX
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentImplementation) FindDocumentsFromPurlReturnsOnCall(i int, result1 []*vex.VEX, result2 error) {
	fake.findDocumentsFromPurlMutex.Lock()
	defer fake.findDocumentsFromPurlMutex.Unlock()
	fake.FindDocumentsFromPurlStub = nil
	if fake.findDocumentsFromPurlReturnsOnCall == nil {
		fake.findDocumentsFromPurlReturnsOnCall = make(map[int]struct {
			result1 []*vex.VEX
			result2 error
		})
	}
	fake.findDocumentsFromPurlReturnsOnCall[i] = struct {
		result1 []*vex.VEX
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentImplementation) GetPackageProbe(arg1 options.Options, arg2 *packageurl.PackageURL) (discovery.VexProbe, error) {
	fake.getPackageProbeMutex.Lock()
	ret, specificReturn := fake.getPackageProbeReturnsOnCall[len(fake.getPackageProbeArgsForCall)]
	fake.getPackageProbeArgsForCall = append(fake.getPackageProbeArgsForCall, struct {
		arg1 options.Options
		arg2 *packageurl.PackageURL
	}{arg1, arg2})
	stub := fake.GetPackageProbeStub
	fakeReturns := fake.getPackageProbeReturns
	fake.recordInvocation("GetPackageProbe", []interface{}{arg1, arg2})
	fake.getPackageProbeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAgentImplementation) GetPackageProbeCallCount() int {
	fake.getPackageProbeMutex.RLock()
	defer fake.getPackageProbeMutex.RUnlock()
	return len(fake.getPackageProbeArgsForCall)
}

func (fake *FakeAgentImplementation) GetPackageProbeCalls(stub func(options.Options, *packageurl.PackageURL) (discovery.VexProbe, error)) {
	fake.getPackageProbeMutex.Lock()
	defer fake.getPackageProbeMutex.Unlock()
	fake.GetPackageProbeStub = stub
}

func (fake *FakeAgentImplementation) GetPackageProbeArgsForCall(i int) (options.Options, *packageurl.PackageURL) {
	fake.getPackageProbeMutex.RLock()
	defer fake.getPackageProbeMutex.RUnlock()
	argsForCall := fake.getPackageProbeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAgentImplementation) GetPackageProbeReturns(result1 discovery.VexProbe, result2 error) {
	fake.getPackageProbeMutex.Lock()
	defer fake.getPackageProbeMutex.Unlock()
	fake.GetPackageProbeStub = nil
	fake.getPackageProbeReturns = struct {
		result1 discovery.VexProbe
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentImplementation) GetPackageProbeReturnsOnCall(i int, result1 discovery.VexProbe, result2 error) {
	fake.getPackageProbeMutex.Lock()
	defer fake.getPackageProbeMutex.Unlock()
	fake.GetPackageProbeStub = nil
	if fake.getPackageProbeReturnsOnCall == nil {
		fake.getPackageProbeReturnsOnCall = make(map[int]struct {
			result1 discovery.VexProbe
			result2 error
		})
	}
	fake.getPackageProbeReturnsOnCall[i] = struct {
		result1 discovery.VexProbe
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentImplementation) ParsePurl(arg1 string) (*packageurl.PackageURL, error) {
	fake.parsePurlMutex.Lock()
	ret, specificReturn := fake.parsePurlReturnsOnCall[len(fake.parsePurlArgsForCall)]
	fake.parsePurlArgsForCall = append(fake.parsePurlArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ParsePurlStub
	fakeReturns := fake.parsePurlReturns
	fake.recordInvocation("ParsePurl", []interface{}{arg1})
	fake.parsePurlMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAgentImplementation) ParsePurlCallCount() int {
	fake.parsePurlMutex.RLock()
	defer fake.parsePurlMutex.RUnlock()
	return len(fake.parsePurlArgsForCall)
}

func (fake *FakeAgentImplementation) ParsePurlCalls(stub func(string) (*packageurl.PackageURL, error)) {
	fake.parsePurlMutex.Lock()
	defer fake.parsePurlMutex.Unlock()
	fake.ParsePurlStub = stub
}

func (fake *FakeAgentImplementation) ParsePurlArgsForCall(i int) string {
	fake.parsePurlMutex.RLock()
	defer fake.parsePurlMutex.RUnlock()
	argsForCall := fake.parsePurlArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAgentImplementation) ParsePurlReturns(result1 *packageurl.PackageURL, result2 error) {
	fake.parsePurlMutex.Lock()
	defer fake.parsePurlMutex.Unlock()
	fake.ParsePurlStub = nil
	fake.parsePurlReturns = struct {
		result1 *packageurl.PackageURL
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentImplementation) ParsePurlReturnsOnCall(i int, result1 *packageurl.PackageURL, result2 error) {
	fake.parsePurlMutex.Lock()
	defer fake.parsePurlMutex.Unlock()
	fake.ParsePurlStub = nil
	if fake.parsePurlReturnsOnCall == nil {
		fake.parsePurlReturnsOnCall = make(map[int]struct {
			result1 *packageurl.PackageURL
			result2 error
		})
	}
	fake.parsePurlReturnsOnCall[i] = struct {
		result1 *packageurl.PackageURL
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findDocumentsFromPurlMutex.RLock()
	defer fake.findDocumentsFromPurlMutex.RUnlock()
	fake.getPackageProbeMutex.RLock()
	defer fake.getPackageProbeMutex.RUnlock()
	fake.parsePurlMutex.RLock()
	defer fake.parsePurlMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAgentImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
